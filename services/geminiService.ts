
import { GoogleGenAI, Type } from "@google/genai";

const MAX_RETRIES = 3;
const INITIAL_BACKOFF = 1000;

// THIS IS YOUR SECRET - DO NOT SHARE THIS WITH USERS
// If someone knows this string, they can generate free keys.
const DEV_AUTH_SECRET = "NEXUS-ULTRA-SECURE-2025-MPESA-BRIDGE";

const safeAiCall = async (fn: () => Promise<any>, fallback: any = null) => {
  let attempt = 0;
  while (attempt < MAX_RETRIES) {
    try {
      const result = await fn();
      if (result) return result;
      throw new Error("Empty response");
    } catch (error: any) {
      attempt++;
      if (attempt >= MAX_RETRIES) break;
      const delay = INITIAL_BACKOFF * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  return fallback;
};

/**
 * A simple but effective hashing algorithm to generate a non-guessable signature.
 */
function calculateSignature(data: string, salt: string): string {
  const input = `${data}:${salt}:${DEV_AUTH_SECRET}`;
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(36).toUpperCase().substring(0, 6);
}

/**
 * Generates a cryptographically signed activation key.
 * Format: RNW-[DAYS]-[SALT]-[SIGNATURE]
 */
export const generateActivationKey = (days: number): string => {
  const salt = Math.random().toString(36).substring(2, 6).toUpperCase();
  const signature = calculateSignature(days.toString(), salt);
  return `RNW-${days}-${salt}-${signature}`;
};

/**
 * Validates the signature of a renewal key.
 */
export const validateRenewalKey = (key: string): number | null => {
  if (!key || !key.startsWith('RNW-')) return null;
  const parts = key.split('-');
  if (parts.length !== 4) return null;
  const days = parseInt(parts[1]);
  const salt = parts[2];
  const providedSignature = parts[3];
  if (isNaN(days) || !salt || !providedSignature) return null;
  const expectedSignature = calculateSignature(days.toString(), salt);
  return providedSignature === expectedSignature ? days : null;
};

/**
 * Generates a signed Market License.
 */
export const generateMarketLicense = async (storeName: string, location: string) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  const prefix = storeName.substring(0, 3).toUpperCase();
  const random = Math.floor(1000 + Math.random() * 9000);
  const salt = Math.random().toString(36).substring(2, 6).toUpperCase();
  
  // Create a verifiable fingerprint for the license
  const baseId = `NEX-${prefix}-${random}`;
  const signature = calculateSignature(baseId, salt);
  const finalLicense = `${baseId}-${salt}-${signature}`;

  const fallback = {
    licenseKey: finalLicense,
    welcomeSummary: `Welcome to NexusMarket Pro. Your ${storeName} instance is active.`,
    suggestedRoles: ["Main Manager", "Lead Cashier"]
  };

  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: `Create a professional supermarket license key for ${storeName} in ${location}. Note: The key is already generated as ${finalLicense}. Please provide the JSON structure around it.`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            licenseKey: { type: Type.STRING },
            welcomeSummary: { type: Type.STRING },
            suggestedRoles: { type: Type.ARRAY, items: { type: Type.STRING } }
          }
        }
      }
    });
    return JSON.parse(response.text || '{}');
  }, fallback);
};

/**
 * Verifies if a License Key was actually generated by the system.
 */
export const verifyMarketLicense = (key: string): boolean => {
  if (!key || !key.startsWith('NEX-')) return false;
  const parts = key.split('-');
  // Format: NEX-PRE-RAND-SALT-SIG (5 parts)
  if (parts.length !== 5) return false;
  
  const baseId = `NEX-${parts[1]}-${parts[2]}`;
  const salt = parts[3];
  const providedSignature = parts[4];
  
  const expectedSignature = calculateSignature(baseId, salt);
  return providedSignature === expectedSignature;
};

// Use gemini-3-pro-preview for advanced reasoning in consultation
export const askConsultant = async (query: string, storeContext: any) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: `You are the NexusMarket AI Consultant. Answer the manager's question professionally and concisely based on this store data. Question: ${query}. Data: ${JSON.stringify(storeContext)}`,
    });
    return response.text;
  }, "I'm having trouble syncing with the store's operational brain right now.");
};

// Loss Prevention & Staff Analytics (Gemini 3 Pro)
export const detectInternalTheft = async (cashierLogs: any[]) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  const fallback = { integrityScore: 95, riskLevel: "STABLE", flaggedEvents: [], auditSummary: "Digital tape is clean. No suspicious patterns detected in recent logs." };
  
  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: `LOSS PREVENTION AUDIT: Analyze these recent POS events. Look specifically for "Phantom Voids" (high-value items scanned then removed). Provide a trust score and risk level. Logs: ${JSON.stringify(cashierLogs)}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            integrityScore: { type: Type.NUMBER },
            riskLevel: { type: Type.STRING },
            flaggedEvents: { 
              type: Type.ARRAY, 
              items: { 
                type: Type.OBJECT, 
                properties: { 
                  time: { type: Type.STRING }, 
                  type: { type: Type.STRING }, 
                  reason: { type: Type.STRING } 
                } 
              } 
            },
            auditSummary: { type: Type.STRING }
          }
        }
      }
    });
    return JSON.parse(response.text || '{}');
  }, fallback);
};

export const generateStoreAudit = async (storeData: any) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: `OPERATIONAL COMMAND: As an expert supermarket consultant, analyze this store data and give the manager 3 high-impact "Directives" for today. Store Data: ${JSON.stringify(storeData)}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            performanceSummary: { type: Type.STRING },
            operationalRisks: { type: Type.ARRAY, items: { type: Type.STRING } },
            automatedDirectives: { type: Type.ARRAY, items: { type: Type.STRING } }
          }
        }
      }
    });
    return JSON.parse(response.text || '{}');
  }, {});
};

export const getInventoryInsights = async (inventory: any[]) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: `STOCK FORECAST: Predict demand for these items. Suggest a markdown strategy for slow movers and a reorder strategy for high-velocity items. Inventory: ${JSON.stringify(inventory.slice(0, 10))}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            forecast: { type: Type.STRING },
            pricingStrategy: { type: Type.STRING },
            risks: { type: Type.ARRAY, items: { type: Type.STRING } },
            recommendations: { type: Type.ARRAY, items: { type: Type.STRING } }
          }
        }
      }
    });
    return JSON.parse(response.text || '{}');
  }, {});
};

export const analyzeStaffLoyalty = async (staff: any[]) => {
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  return safeAiCall(async () => {
    const response = await ai.models.generateContent({
      model: "gemini-3-pro-preview",
      contents: `TALENT ANALYTICS: Evaluate these staff members. Identify a "Top Performer" and suggest a specific recognition. Staff: ${JSON.stringify(staff)}`,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            topPerformer: { type: Type.STRING },
            recognitionNudge: { type: Type.STRING },
            loyaltyBonusSuggestions: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { name: { type: Type.STRING }, bonusReason: { type: Type.STRING } } } }
          }
        }
      }
    });
    return JSON.parse(response.text || '{}');
  }, {});
};
